# This file is automatically generated. Do not edit!

import pytest
import operator

from nada_dsl import *
from nada_dsl.compiler_frontend import (
    nada_dsl_to_nada_mir,
    to_input_list,
    to_type_dict,
    to_fn_dict,
    process_operation,
    INPUTS,
    PARTIES,
    FUNCTIONS,
)


@pytest.fixture(autouse=True)
def clean_inputs():
    PARTIES.clear()
    INPUTS.clear()
    FUNCTIONS.clear()
    yield


def input_reference(ref) -> str:
    return ref["InputReference"]["refers_to"]


def literal_reference(ref) -> str:
    return ref["LiteralReference"]["refers_to"]


def create_input(cls, name: str, party: str, **kwargs):
    return cls(Input(name=name, party=Party(party)), **kwargs)


def create_literal(cls, value: Any, **kwargs):
    return cls(value=value, **kwargs)


def create_collection(cls, inner_input, size, **kwargs):
    return cls(inner_input, size, **kwargs)


def create_output(root: AllTypes, name: str, party: str) -> Output:
    return Output(root, name, Party(party))



@pytest.mark.parametrize(
    "operator",
    [
        operator.add,
        operator.sub,
        operator.truediv,
        operator.lt,
        operator.gt,
        operator.le,
        operator.ge,
        operator.eq
    ],
)
def test_rational_digit_checks_literal(operator):
    left = create_literal(Rational, 4.2, digits=3)
    right = create_literal(Rational, 4.2, digits=4)
    with pytest.raises(Exception):
        operator(left, right)

@pytest.mark.parametrize(
    "operator",
    [
        operator.add,
        operator.sub,
        operator.truediv,
        operator.lt,
        operator.gt,
        operator.le,
        operator.ge,
        operator.eq,
        PublicRational.public_equals
    ],
)
def test_rational_digit_checks_public(operator):
    left = create_input(PublicRational, "left", "party", digits=3)
    right = create_input(PublicRational, "right", "party", digits=4)
    with pytest.raises(Exception):
        operator(left, right)

@pytest.mark.parametrize(
    "operator",
    [
        operator.add,
        operator.sub,
        operator.lt,
        operator.gt,
        operator.le,
        operator.ge,
        operator.eq,
        SecretRational.public_equals
    ],
)
def test_rational_digit_checks_secret(operator):
    left = create_input(SecretRational, "left", "party", digits=3)
    right = create_input(SecretRational, "right", "party", digits=4)
    with pytest.raises(Exception):
        operator(left, right)

def test_rational_type_conversion_literal():
    input = create_literal(Rational, 4.2, digits=3)
    converted_input = to_type_dict(input)
    expected = {"Literal": {"Rational": {"digits": 3}}}
    assert converted_input == expected

def test_rational_type_conversion_public():
    input = create_input(PublicRational, "name", "party", digits=3)
    converted_input = to_type_dict(input)
    expected = {"Public": {"Rational": {"digits": 3}}}
    assert converted_input == expected

def test_rational_type_conversion_secret():
    input = create_input(SecretRational, "name", "party", digits=3)
    converted_input = to_type_dict(input)
    expected = {"Secret": {"Rational": {"digits": 3}}}
    assert converted_input == expected

@pytest.mark.parametrize(
    ("operator", "name", "ty"),
    [
        (operator.eq, "LiteralReference", {"Literal": {"Boolean": None}})
    ],
)
def test_binary_operator_boolean_boolean(operator, name, ty):
    left = create_literal(Boolean, True)
    right = create_literal(Boolean, True)
    program_operation = operator(left, right)
    op = process_operation(program_operation)
    assert list(op.keys()) == [name]

    inner = op[name]

    
    
    assert inner["type"] == ty

@pytest.mark.parametrize(
    ("operator", "name", "ty"),
    [
        (operator.eq, "Equals", {"Public": {"Boolean": None}})
    ],
)
def test_binary_operator_boolean_publicboolean(operator, name, ty):
    left = create_literal(Boolean, True)
    right = create_input(PublicBoolean, "right", "party")
    program_operation = operator(left, right)
    op = process_operation(program_operation)
    assert list(op.keys()) == [name]

    inner = op[name]

    assert len(literal_reference(inner["left"])) == 32
    assert input_reference(inner["right"]) == "right"
    assert inner["type"] == ty

@pytest.mark.parametrize(
    ("operator", "name", "ty"),
    [
        (operator.eq, "Equals", {"Secret": {"Boolean": None}})
    ],
)
def test_binary_operator_boolean_secretboolean(operator, name, ty):
    left = create_literal(Boolean, True)
    right = create_input(SecretBoolean, "right", "party")
    program_operation = operator(left, right)
    op = process_operation(program_operation)
    assert list(op.keys()) == [name]

    inner = op[name]

    assert len(literal_reference(inner["left"])) == 32
    assert input_reference(inner["right"]) == "right"
    assert inner["type"] == ty

@pytest.mark.parametrize(
    ("operator", "name", "ty"),
    [
        (operator.eq, "Equals", {"Public": {"Boolean": None}})
    ],
)
def test_binary_operator_publicboolean_boolean(operator, name, ty):
    left = create_input(PublicBoolean, "left", "party")
    right = create_literal(Boolean, True)
    program_operation = operator(left, right)
    op = process_operation(program_operation)
    assert list(op.keys()) == [name]

    inner = op[name]

    assert input_reference(inner["left"]) == "left"
    assert len(literal_reference(inner["right"])) == 32
    assert inner["type"] == ty

@pytest.mark.parametrize(
    ("operator", "name", "ty"),
    [
        (operator.eq, "Equals", {"Public": {"Boolean": None}}),
        (PublicBoolean.public_equals, "PublicEquals", {"Public": {"Boolean": None}})
    ],
)
def test_binary_operator_publicboolean_publicboolean(operator, name, ty):
    left = create_input(PublicBoolean, "left", "party")
    right = create_input(PublicBoolean, "right", "party")
    program_operation = operator(left, right)
    op = process_operation(program_operation)
    assert list(op.keys()) == [name]

    inner = op[name]

    assert input_reference(inner["left"]) == "left"
    assert input_reference(inner["right"]) == "right"
    assert inner["type"] == ty

@pytest.mark.parametrize(
    ("operator", "name", "ty"),
    [
        (operator.eq, "Equals", {"Secret": {"Boolean": None}}),
        (PublicBoolean.public_equals, "PublicEquals", {"Secret": {"Boolean": None}})
    ],
)
def test_binary_operator_publicboolean_secretboolean(operator, name, ty):
    left = create_input(PublicBoolean, "left", "party")
    right = create_input(SecretBoolean, "right", "party")
    program_operation = operator(left, right)
    op = process_operation(program_operation)
    assert list(op.keys()) == [name]

    inner = op[name]

    assert input_reference(inner["left"]) == "left"
    assert input_reference(inner["right"]) == "right"
    assert inner["type"] == ty

@pytest.mark.parametrize(
    ("operator", "name", "ty"),
    [
        (operator.eq, "Equals", {"Secret": {"Boolean": None}})
    ],
)
def test_binary_operator_secretboolean_boolean(operator, name, ty):
    left = create_input(SecretBoolean, "left", "party")
    right = create_literal(Boolean, True)
    program_operation = operator(left, right)
    op = process_operation(program_operation)
    assert list(op.keys()) == [name]

    inner = op[name]

    assert input_reference(inner["left"]) == "left"
    assert len(literal_reference(inner["right"])) == 32
    assert inner["type"] == ty

@pytest.mark.parametrize(
    ("operator", "name", "ty"),
    [
        (operator.eq, "Equals", {"Secret": {"Boolean": None}}),
        (SecretBoolean.public_equals, "PublicEquals", {"Secret": {"Boolean": None}})
    ],
)
def test_binary_operator_secretboolean_publicboolean(operator, name, ty):
    left = create_input(SecretBoolean, "left", "party")
    right = create_input(PublicBoolean, "right", "party")
    program_operation = operator(left, right)
    op = process_operation(program_operation)
    assert list(op.keys()) == [name]

    inner = op[name]

    assert input_reference(inner["left"]) == "left"
    assert input_reference(inner["right"]) == "right"
    assert inner["type"] == ty

@pytest.mark.parametrize(
    ("operator", "name", "ty"),
    [
        (operator.eq, "Equals", {"Secret": {"Boolean": None}}),
        (SecretBoolean.public_equals, "PublicEquals", {"Secret": {"Boolean": None}})
    ],
)
def test_binary_operator_secretboolean_secretboolean(operator, name, ty):
    left = create_input(SecretBoolean, "left", "party")
    right = create_input(SecretBoolean, "right", "party")
    program_operation = operator(left, right)
    op = process_operation(program_operation)
    assert list(op.keys()) == [name]

    inner = op[name]

    assert input_reference(inner["left"]) == "left"
    assert input_reference(inner["right"]) == "right"
    assert inner["type"] == ty

@pytest.mark.parametrize(
    ("operator", "name", "ty"),
    [
        (operator.add, "LiteralReference", {"Literal": {"Integer": None}}),
        (operator.sub, "LiteralReference", {"Literal": {"Integer": None}}),
        (operator.mul, "LiteralReference", {"Literal": {"Integer": None}}),
        (operator.truediv, "LiteralReference", {"Literal": {"Integer": None}}),
        (operator.mod, "LiteralReference", {"Literal": {"Integer": None}}),
        (operator.pow, "LiteralReference", {"Literal": {"Integer": None}}),
        (operator.lt, "LiteralReference", {"Literal": {"Boolean": None}}),
        (operator.gt, "LiteralReference", {"Literal": {"Boolean": None}}),
        (operator.le, "LiteralReference", {"Literal": {"Boolean": None}}),
        (operator.ge, "LiteralReference", {"Literal": {"Boolean": None}}),
        (operator.eq, "LiteralReference", {"Literal": {"Boolean": None}})
    ],
)
def test_binary_operator_integer_integer(operator, name, ty):
    left = create_literal(Integer, -42)
    right = create_literal(Integer, -42)
    program_operation = operator(left, right)
    op = process_operation(program_operation)
    assert list(op.keys()) == [name]

    inner = op[name]

    
    
    assert inner["type"] == ty

@pytest.mark.parametrize(
    ("operator", "name", "ty"),
    [
        (operator.add, "Addition", {"Public": {"Integer": None}}),
        (operator.sub, "Subtraction", {"Public": {"Integer": None}}),
        (operator.mul, "Multiplication", {"Public": {"Integer": None}}),
        (operator.truediv, "Division", {"Public": {"Integer": None}}),
        (operator.mod, "Modulo", {"Public": {"Integer": None}}),
        (operator.pow, "Power", {"Public": {"Integer": None}}),
        (operator.lt, "LessThan", {"Public": {"Boolean": None}}),
        (operator.gt, "GreaterThan", {"Public": {"Boolean": None}}),
        (operator.le, "LessOrEqualThan", {"Public": {"Boolean": None}}),
        (operator.ge, "GreaterOrEqualThan", {"Public": {"Boolean": None}}),
        (operator.eq, "Equals", {"Public": {"Boolean": None}})
    ],
)
def test_binary_operator_integer_publicinteger(operator, name, ty):
    left = create_literal(Integer, -42)
    right = create_input(PublicInteger, "right", "party")
    program_operation = operator(left, right)
    op = process_operation(program_operation)
    assert list(op.keys()) == [name]

    inner = op[name]

    assert len(literal_reference(inner["left"])) == 32
    assert input_reference(inner["right"]) == "right"
    assert inner["type"] == ty

@pytest.mark.parametrize(
    ("operator", "name", "ty"),
    [
        (operator.add, "Addition", {"Secret": {"Integer": None}}),
        (operator.sub, "Subtraction", {"Secret": {"Integer": None}}),
        (operator.mul, "Multiplication", {"Secret": {"Integer": None}}),
        (operator.lt, "LessThan", {"Secret": {"Boolean": None}}),
        (operator.gt, "GreaterThan", {"Secret": {"Boolean": None}}),
        (operator.le, "LessOrEqualThan", {"Secret": {"Boolean": None}}),
        (operator.ge, "GreaterOrEqualThan", {"Secret": {"Boolean": None}}),
        (operator.eq, "Equals", {"Secret": {"Boolean": None}})
    ],
)
def test_binary_operator_integer_secretinteger(operator, name, ty):
    left = create_literal(Integer, -42)
    right = create_input(SecretInteger, "right", "party")
    program_operation = operator(left, right)
    op = process_operation(program_operation)
    assert list(op.keys()) == [name]

    inner = op[name]

    assert len(literal_reference(inner["left"])) == 32
    assert input_reference(inner["right"]) == "right"
    assert inner["type"] == ty

@pytest.mark.parametrize(
    ("operator", "name", "ty"),
    [
        (operator.add, "Addition", {"Public": {"Integer": None}}),
        (operator.sub, "Subtraction", {"Public": {"Integer": None}}),
        (operator.mul, "Multiplication", {"Public": {"Integer": None}}),
        (operator.truediv, "Division", {"Public": {"Integer": None}}),
        (operator.mod, "Modulo", {"Public": {"Integer": None}}),
        (operator.pow, "Power", {"Public": {"Integer": None}}),
        (operator.lt, "LessThan", {"Public": {"Boolean": None}}),
        (operator.gt, "GreaterThan", {"Public": {"Boolean": None}}),
        (operator.le, "LessOrEqualThan", {"Public": {"Boolean": None}}),
        (operator.ge, "GreaterOrEqualThan", {"Public": {"Boolean": None}}),
        (operator.eq, "Equals", {"Public": {"Boolean": None}})
    ],
)
def test_binary_operator_publicinteger_integer(operator, name, ty):
    left = create_input(PublicInteger, "left", "party")
    right = create_literal(Integer, -42)
    program_operation = operator(left, right)
    op = process_operation(program_operation)
    assert list(op.keys()) == [name]

    inner = op[name]

    assert input_reference(inner["left"]) == "left"
    assert len(literal_reference(inner["right"])) == 32
    assert inner["type"] == ty

@pytest.mark.parametrize(
    ("operator", "name", "ty"),
    [
        (operator.add, "Addition", {"Public": {"Integer": None}}),
        (operator.sub, "Subtraction", {"Public": {"Integer": None}}),
        (operator.mul, "Multiplication", {"Public": {"Integer": None}}),
        (operator.truediv, "Division", {"Public": {"Integer": None}}),
        (operator.mod, "Modulo", {"Public": {"Integer": None}}),
        (operator.pow, "Power", {"Public": {"Integer": None}}),
        (operator.lt, "LessThan", {"Public": {"Boolean": None}}),
        (operator.gt, "GreaterThan", {"Public": {"Boolean": None}}),
        (operator.le, "LessOrEqualThan", {"Public": {"Boolean": None}}),
        (operator.ge, "GreaterOrEqualThan", {"Public": {"Boolean": None}}),
        (operator.eq, "Equals", {"Public": {"Boolean": None}}),
        (PublicInteger.public_equals, "PublicEquals", {"Public": {"Boolean": None}})
    ],
)
def test_binary_operator_publicinteger_publicinteger(operator, name, ty):
    left = create_input(PublicInteger, "left", "party")
    right = create_input(PublicInteger, "right", "party")
    program_operation = operator(left, right)
    op = process_operation(program_operation)
    assert list(op.keys()) == [name]

    inner = op[name]

    assert input_reference(inner["left"]) == "left"
    assert input_reference(inner["right"]) == "right"
    assert inner["type"] == ty

@pytest.mark.parametrize(
    ("operator", "name", "ty"),
    [
        (operator.add, "Addition", {"Secret": {"Integer": None}}),
        (operator.sub, "Subtraction", {"Secret": {"Integer": None}}),
        (operator.mul, "Multiplication", {"Secret": {"Integer": None}}),
        (operator.lt, "LessThan", {"Secret": {"Boolean": None}}),
        (operator.gt, "GreaterThan", {"Secret": {"Boolean": None}}),
        (operator.le, "LessOrEqualThan", {"Secret": {"Boolean": None}}),
        (operator.ge, "GreaterOrEqualThan", {"Secret": {"Boolean": None}}),
        (operator.eq, "Equals", {"Secret": {"Boolean": None}}),
        (PublicInteger.public_equals, "PublicEquals", {"Secret": {"Boolean": None}})
    ],
)
def test_binary_operator_publicinteger_secretinteger(operator, name, ty):
    left = create_input(PublicInteger, "left", "party")
    right = create_input(SecretInteger, "right", "party")
    program_operation = operator(left, right)
    op = process_operation(program_operation)
    assert list(op.keys()) == [name]

    inner = op[name]

    assert input_reference(inner["left"]) == "left"
    assert input_reference(inner["right"]) == "right"
    assert inner["type"] == ty

@pytest.mark.parametrize(
    ("operator", "name", "ty"),
    [
        (operator.add, "Addition", {"Secret": {"Integer": None}}),
        (operator.sub, "Subtraction", {"Secret": {"Integer": None}}),
        (operator.mul, "Multiplication", {"Secret": {"Integer": None}}),
        (operator.truediv, "Division", {"Secret": {"Integer": None}}),
        (operator.mod, "Modulo", {"Secret": {"Integer": None}}),
        (operator.pow, "Power", {"Secret": {"Integer": None}}),
        (operator.lt, "LessThan", {"Secret": {"Boolean": None}}),
        (operator.gt, "GreaterThan", {"Secret": {"Boolean": None}}),
        (operator.le, "LessOrEqualThan", {"Secret": {"Boolean": None}}),
        (operator.ge, "GreaterOrEqualThan", {"Secret": {"Boolean": None}}),
        (operator.eq, "Equals", {"Secret": {"Boolean": None}})
    ],
)
def test_binary_operator_secretinteger_integer(operator, name, ty):
    left = create_input(SecretInteger, "left", "party")
    right = create_literal(Integer, -42)
    program_operation = operator(left, right)
    op = process_operation(program_operation)
    assert list(op.keys()) == [name]

    inner = op[name]

    assert input_reference(inner["left"]) == "left"
    assert len(literal_reference(inner["right"])) == 32
    assert inner["type"] == ty

@pytest.mark.parametrize(
    ("operator", "name", "ty"),
    [
        (operator.add, "Addition", {"Secret": {"Integer": None}}),
        (operator.sub, "Subtraction", {"Secret": {"Integer": None}}),
        (operator.mul, "Multiplication", {"Secret": {"Integer": None}}),
        (operator.truediv, "Division", {"Secret": {"Integer": None}}),
        (operator.mod, "Modulo", {"Secret": {"Integer": None}}),
        (operator.pow, "Power", {"Secret": {"Integer": None}}),
        (operator.lt, "LessThan", {"Secret": {"Boolean": None}}),
        (operator.gt, "GreaterThan", {"Secret": {"Boolean": None}}),
        (operator.le, "LessOrEqualThan", {"Secret": {"Boolean": None}}),
        (operator.ge, "GreaterOrEqualThan", {"Secret": {"Boolean": None}}),
        (operator.eq, "Equals", {"Secret": {"Boolean": None}}),
        (SecretInteger.public_equals, "PublicEquals", {"Secret": {"Boolean": None}})
    ],
)
def test_binary_operator_secretinteger_publicinteger(operator, name, ty):
    left = create_input(SecretInteger, "left", "party")
    right = create_input(PublicInteger, "right", "party")
    program_operation = operator(left, right)
    op = process_operation(program_operation)
    assert list(op.keys()) == [name]

    inner = op[name]

    assert input_reference(inner["left"]) == "left"
    assert input_reference(inner["right"]) == "right"
    assert inner["type"] == ty

@pytest.mark.parametrize(
    ("operator", "name", "ty"),
    [
        (operator.add, "Addition", {"Secret": {"Integer": None}}),
        (operator.sub, "Subtraction", {"Secret": {"Integer": None}}),
        (operator.mul, "Multiplication", {"Secret": {"Integer": None}}),
        (operator.lt, "LessThan", {"Secret": {"Boolean": None}}),
        (operator.gt, "GreaterThan", {"Secret": {"Boolean": None}}),
        (operator.le, "LessOrEqualThan", {"Secret": {"Boolean": None}}),
        (operator.ge, "GreaterOrEqualThan", {"Secret": {"Boolean": None}}),
        (operator.eq, "Equals", {"Secret": {"Boolean": None}}),
        (SecretInteger.public_equals, "PublicEquals", {"Secret": {"Boolean": None}})
    ],
)
def test_binary_operator_secretinteger_secretinteger(operator, name, ty):
    left = create_input(SecretInteger, "left", "party")
    right = create_input(SecretInteger, "right", "party")
    program_operation = operator(left, right)
    op = process_operation(program_operation)
    assert list(op.keys()) == [name]

    inner = op[name]

    assert input_reference(inner["left"]) == "left"
    assert input_reference(inner["right"]) == "right"
    assert inner["type"] == ty

@pytest.mark.parametrize(
    ("operator", "name", "ty"),
    [
        (operator.add, "LiteralReference", {"Literal": {"UnsignedInteger": None}}),
        (operator.sub, "LiteralReference", {"Literal": {"UnsignedInteger": None}}),
        (operator.mul, "LiteralReference", {"Literal": {"UnsignedInteger": None}}),
        (operator.truediv, "LiteralReference", {"Literal": {"UnsignedInteger": None}}),
        (operator.mod, "LiteralReference", {"Literal": {"UnsignedInteger": None}}),
        (operator.pow, "LiteralReference", {"Literal": {"UnsignedInteger": None}}),
        (operator.lshift, "LiteralReference", {"Literal": {"UnsignedInteger": None}}),
        (operator.rshift, "LiteralReference", {"Literal": {"UnsignedInteger": None}}),
        (operator.lt, "LiteralReference", {"Literal": {"Boolean": None}}),
        (operator.gt, "LiteralReference", {"Literal": {"Boolean": None}}),
        (operator.le, "LiteralReference", {"Literal": {"Boolean": None}}),
        (operator.ge, "LiteralReference", {"Literal": {"Boolean": None}}),
        (operator.eq, "LiteralReference", {"Literal": {"Boolean": None}})
    ],
)
def test_binary_operator_unsignedinteger_unsignedinteger(operator, name, ty):
    left = create_literal(UnsignedInteger, 42)
    right = create_literal(UnsignedInteger, 42)
    program_operation = operator(left, right)
    op = process_operation(program_operation)
    assert list(op.keys()) == [name]

    inner = op[name]

    
    
    assert inner["type"] == ty

@pytest.mark.parametrize(
    ("operator", "name", "ty"),
    [
        (operator.add, "Addition", {"Public": {"UnsignedInteger": None}}),
        (operator.sub, "Subtraction", {"Public": {"UnsignedInteger": None}}),
        (operator.mul, "Multiplication", {"Public": {"UnsignedInteger": None}}),
        (operator.truediv, "Division", {"Public": {"UnsignedInteger": None}}),
        (operator.mod, "Modulo", {"Public": {"UnsignedInteger": None}}),
        (operator.pow, "Power", {"Public": {"UnsignedInteger": None}}),
        (operator.lshift, "LeftShift", {"Public": {"UnsignedInteger": None}}),
        (operator.rshift, "RightShift", {"Public": {"UnsignedInteger": None}}),
        (operator.lt, "LessThan", {"Public": {"Boolean": None}}),
        (operator.gt, "GreaterThan", {"Public": {"Boolean": None}}),
        (operator.le, "LessOrEqualThan", {"Public": {"Boolean": None}}),
        (operator.ge, "GreaterOrEqualThan", {"Public": {"Boolean": None}}),
        (operator.eq, "Equals", {"Public": {"Boolean": None}})
    ],
)
def test_binary_operator_unsignedinteger_publicunsignedinteger(operator, name, ty):
    left = create_literal(UnsignedInteger, 42)
    right = create_input(PublicUnsignedInteger, "right", "party")
    program_operation = operator(left, right)
    op = process_operation(program_operation)
    assert list(op.keys()) == [name]

    inner = op[name]

    assert len(literal_reference(inner["left"])) == 32
    assert input_reference(inner["right"]) == "right"
    assert inner["type"] == ty

@pytest.mark.parametrize(
    ("operator", "name", "ty"),
    [
        (operator.add, "Addition", {"Secret": {"UnsignedInteger": None}}),
        (operator.sub, "Subtraction", {"Secret": {"UnsignedInteger": None}}),
        (operator.mul, "Multiplication", {"Secret": {"UnsignedInteger": None}}),
        (operator.lt, "LessThan", {"Secret": {"Boolean": None}}),
        (operator.gt, "GreaterThan", {"Secret": {"Boolean": None}}),
        (operator.le, "LessOrEqualThan", {"Secret": {"Boolean": None}}),
        (operator.ge, "GreaterOrEqualThan", {"Secret": {"Boolean": None}}),
        (operator.eq, "Equals", {"Secret": {"Boolean": None}})
    ],
)
def test_binary_operator_unsignedinteger_secretunsignedinteger(operator, name, ty):
    left = create_literal(UnsignedInteger, 42)
    right = create_input(SecretUnsignedInteger, "right", "party")
    program_operation = operator(left, right)
    op = process_operation(program_operation)
    assert list(op.keys()) == [name]

    inner = op[name]

    assert len(literal_reference(inner["left"])) == 32
    assert input_reference(inner["right"]) == "right"
    assert inner["type"] == ty

@pytest.mark.parametrize(
    ("operator", "name", "ty"),
    [
        (operator.add, "Addition", {"Public": {"UnsignedInteger": None}}),
        (operator.sub, "Subtraction", {"Public": {"UnsignedInteger": None}}),
        (operator.mul, "Multiplication", {"Public": {"UnsignedInteger": None}}),
        (operator.truediv, "Division", {"Public": {"UnsignedInteger": None}}),
        (operator.mod, "Modulo", {"Public": {"UnsignedInteger": None}}),
        (operator.pow, "Power", {"Public": {"UnsignedInteger": None}}),
        (operator.lshift, "LeftShift", {"Public": {"UnsignedInteger": None}}),
        (operator.rshift, "RightShift", {"Public": {"UnsignedInteger": None}}),
        (operator.lt, "LessThan", {"Public": {"Boolean": None}}),
        (operator.gt, "GreaterThan", {"Public": {"Boolean": None}}),
        (operator.le, "LessOrEqualThan", {"Public": {"Boolean": None}}),
        (operator.ge, "GreaterOrEqualThan", {"Public": {"Boolean": None}}),
        (operator.eq, "Equals", {"Public": {"Boolean": None}})
    ],
)
def test_binary_operator_publicunsignedinteger_unsignedinteger(operator, name, ty):
    left = create_input(PublicUnsignedInteger, "left", "party")
    right = create_literal(UnsignedInteger, 42)
    program_operation = operator(left, right)
    op = process_operation(program_operation)
    assert list(op.keys()) == [name]

    inner = op[name]

    assert input_reference(inner["left"]) == "left"
    assert len(literal_reference(inner["right"])) == 32
    assert inner["type"] == ty

@pytest.mark.parametrize(
    ("operator", "name", "ty"),
    [
        (operator.add, "Addition", {"Public": {"UnsignedInteger": None}}),
        (operator.sub, "Subtraction", {"Public": {"UnsignedInteger": None}}),
        (operator.mul, "Multiplication", {"Public": {"UnsignedInteger": None}}),
        (operator.truediv, "Division", {"Public": {"UnsignedInteger": None}}),
        (operator.mod, "Modulo", {"Public": {"UnsignedInteger": None}}),
        (operator.pow, "Power", {"Public": {"UnsignedInteger": None}}),
        (operator.lshift, "LeftShift", {"Public": {"UnsignedInteger": None}}),
        (operator.rshift, "RightShift", {"Public": {"UnsignedInteger": None}}),
        (operator.lt, "LessThan", {"Public": {"Boolean": None}}),
        (operator.gt, "GreaterThan", {"Public": {"Boolean": None}}),
        (operator.le, "LessOrEqualThan", {"Public": {"Boolean": None}}),
        (operator.ge, "GreaterOrEqualThan", {"Public": {"Boolean": None}}),
        (operator.eq, "Equals", {"Public": {"Boolean": None}}),
        (PublicUnsignedInteger.public_equals, "PublicEquals", {"Public": {"Boolean": None}})
    ],
)
def test_binary_operator_publicunsignedinteger_publicunsignedinteger(operator, name, ty):
    left = create_input(PublicUnsignedInteger, "left", "party")
    right = create_input(PublicUnsignedInteger, "right", "party")
    program_operation = operator(left, right)
    op = process_operation(program_operation)
    assert list(op.keys()) == [name]

    inner = op[name]

    assert input_reference(inner["left"]) == "left"
    assert input_reference(inner["right"]) == "right"
    assert inner["type"] == ty

@pytest.mark.parametrize(
    ("operator", "name", "ty"),
    [
        (operator.add, "Addition", {"Secret": {"UnsignedInteger": None}}),
        (operator.sub, "Subtraction", {"Secret": {"UnsignedInteger": None}}),
        (operator.mul, "Multiplication", {"Secret": {"UnsignedInteger": None}}),
        (operator.lt, "LessThan", {"Secret": {"Boolean": None}}),
        (operator.gt, "GreaterThan", {"Secret": {"Boolean": None}}),
        (operator.le, "LessOrEqualThan", {"Secret": {"Boolean": None}}),
        (operator.ge, "GreaterOrEqualThan", {"Secret": {"Boolean": None}}),
        (operator.eq, "Equals", {"Secret": {"Boolean": None}}),
        (PublicUnsignedInteger.public_equals, "PublicEquals", {"Secret": {"Boolean": None}})
    ],
)
def test_binary_operator_publicunsignedinteger_secretunsignedinteger(operator, name, ty):
    left = create_input(PublicUnsignedInteger, "left", "party")
    right = create_input(SecretUnsignedInteger, "right", "party")
    program_operation = operator(left, right)
    op = process_operation(program_operation)
    assert list(op.keys()) == [name]

    inner = op[name]

    assert input_reference(inner["left"]) == "left"
    assert input_reference(inner["right"]) == "right"
    assert inner["type"] == ty

@pytest.mark.parametrize(
    ("operator", "name", "ty"),
    [
        (operator.add, "Addition", {"Secret": {"UnsignedInteger": None}}),
        (operator.sub, "Subtraction", {"Secret": {"UnsignedInteger": None}}),
        (operator.mul, "Multiplication", {"Secret": {"UnsignedInteger": None}}),
        (operator.truediv, "Division", {"Secret": {"UnsignedInteger": None}}),
        (operator.mod, "Modulo", {"Secret": {"UnsignedInteger": None}}),
        (operator.pow, "Power", {"Secret": {"UnsignedInteger": None}}),
        (operator.lshift, "LeftShift", {"Secret": {"UnsignedInteger": None}}),
        (operator.rshift, "RightShift", {"Secret": {"UnsignedInteger": None}}),
        (operator.lt, "LessThan", {"Secret": {"Boolean": None}}),
        (operator.gt, "GreaterThan", {"Secret": {"Boolean": None}}),
        (operator.le, "LessOrEqualThan", {"Secret": {"Boolean": None}}),
        (operator.ge, "GreaterOrEqualThan", {"Secret": {"Boolean": None}}),
        (operator.eq, "Equals", {"Secret": {"Boolean": None}})
    ],
)
def test_binary_operator_secretunsignedinteger_unsignedinteger(operator, name, ty):
    left = create_input(SecretUnsignedInteger, "left", "party")
    right = create_literal(UnsignedInteger, 42)
    program_operation = operator(left, right)
    op = process_operation(program_operation)
    assert list(op.keys()) == [name]

    inner = op[name]

    assert input_reference(inner["left"]) == "left"
    assert len(literal_reference(inner["right"])) == 32
    assert inner["type"] == ty

@pytest.mark.parametrize(
    ("operator", "name", "ty"),
    [
        (operator.add, "Addition", {"Secret": {"UnsignedInteger": None}}),
        (operator.sub, "Subtraction", {"Secret": {"UnsignedInteger": None}}),
        (operator.mul, "Multiplication", {"Secret": {"UnsignedInteger": None}}),
        (operator.truediv, "Division", {"Secret": {"UnsignedInteger": None}}),
        (operator.mod, "Modulo", {"Secret": {"UnsignedInteger": None}}),
        (operator.pow, "Power", {"Secret": {"UnsignedInteger": None}}),
        (operator.lshift, "LeftShift", {"Secret": {"UnsignedInteger": None}}),
        (operator.rshift, "RightShift", {"Secret": {"UnsignedInteger": None}}),
        (operator.lt, "LessThan", {"Secret": {"Boolean": None}}),
        (operator.gt, "GreaterThan", {"Secret": {"Boolean": None}}),
        (operator.le, "LessOrEqualThan", {"Secret": {"Boolean": None}}),
        (operator.ge, "GreaterOrEqualThan", {"Secret": {"Boolean": None}}),
        (operator.eq, "Equals", {"Secret": {"Boolean": None}}),
        (SecretUnsignedInteger.public_equals, "PublicEquals", {"Secret": {"Boolean": None}})
    ],
)
def test_binary_operator_secretunsignedinteger_publicunsignedinteger(operator, name, ty):
    left = create_input(SecretUnsignedInteger, "left", "party")
    right = create_input(PublicUnsignedInteger, "right", "party")
    program_operation = operator(left, right)
    op = process_operation(program_operation)
    assert list(op.keys()) == [name]

    inner = op[name]

    assert input_reference(inner["left"]) == "left"
    assert input_reference(inner["right"]) == "right"
    assert inner["type"] == ty

@pytest.mark.parametrize(
    ("operator", "name", "ty"),
    [
        (operator.add, "Addition", {"Secret": {"UnsignedInteger": None}}),
        (operator.sub, "Subtraction", {"Secret": {"UnsignedInteger": None}}),
        (operator.mul, "Multiplication", {"Secret": {"UnsignedInteger": None}}),
        (operator.lt, "LessThan", {"Secret": {"Boolean": None}}),
        (operator.gt, "GreaterThan", {"Secret": {"Boolean": None}}),
        (operator.le, "LessOrEqualThan", {"Secret": {"Boolean": None}}),
        (operator.ge, "GreaterOrEqualThan", {"Secret": {"Boolean": None}}),
        (operator.eq, "Equals", {"Secret": {"Boolean": None}}),
        (SecretUnsignedInteger.public_equals, "PublicEquals", {"Secret": {"Boolean": None}})
    ],
)
def test_binary_operator_secretunsignedinteger_secretunsignedinteger(operator, name, ty):
    left = create_input(SecretUnsignedInteger, "left", "party")
    right = create_input(SecretUnsignedInteger, "right", "party")
    program_operation = operator(left, right)
    op = process_operation(program_operation)
    assert list(op.keys()) == [name]

    inner = op[name]

    assert input_reference(inner["left"]) == "left"
    assert input_reference(inner["right"]) == "right"
    assert inner["type"] == ty

@pytest.mark.parametrize(
    ("operator", "name", "ty"),
    [
        (operator.add, "LiteralReference", {"Literal": {"Rational": {"digits": 3}}}),
        (operator.sub, "LiteralReference", {"Literal": {"Rational": {"digits": 3}}}),
        (operator.mul, "LiteralReference", {"Literal": {"Rational": {"digits": 6}}}),
        (operator.truediv, "LiteralReference", {"Literal": {"Rational": {"digits": 3}}}),
        (operator.lt, "LiteralReference", {"Literal": {"Boolean": None}}),
        (operator.gt, "LiteralReference", {"Literal": {"Boolean": None}}),
        (operator.le, "LiteralReference", {"Literal": {"Boolean": None}}),
        (operator.ge, "LiteralReference", {"Literal": {"Boolean": None}}),
        (operator.eq, "LiteralReference", {"Literal": {"Boolean": None}})
    ],
)
def test_binary_operator_rational_rational(operator, name, ty):
    left = create_literal(Rational, 4.2, digits=3)
    right = create_literal(Rational, 4.2, digits=3)
    program_operation = operator(left, right)
    op = process_operation(program_operation)
    assert list(op.keys()) == [name]

    inner = op[name]

    
    
    assert inner["type"] == ty

@pytest.mark.parametrize(
    ("operator", "name", "ty"),
    [
        (operator.add, "Addition", {"Public": {"Rational": {"digits": 3}}}),
        (operator.sub, "Subtraction", {"Public": {"Rational": {"digits": 3}}}),
        (operator.mul, "Multiplication", {"Public": {"Rational": {"digits": 6}}}),
        (operator.truediv, "Division", {"Public": {"Rational": {"digits": 3}}}),
        (operator.lt, "LessThan", {"Public": {"Boolean": None}}),
        (operator.gt, "GreaterThan", {"Public": {"Boolean": None}}),
        (operator.le, "LessOrEqualThan", {"Public": {"Boolean": None}}),
        (operator.ge, "GreaterOrEqualThan", {"Public": {"Boolean": None}}),
        (operator.eq, "Equals", {"Public": {"Boolean": None}})
    ],
)
def test_binary_operator_rational_publicrational(operator, name, ty):
    left = create_literal(Rational, 4.2, digits=3)
    right = create_input(PublicRational, "right", "party", digits=3)
    program_operation = operator(left, right)
    op = process_operation(program_operation)
    assert list(op.keys()) == [name]

    inner = op[name]

    assert len(literal_reference(inner["left"])) == 32
    assert input_reference(inner["right"]) == "right"
    assert inner["type"] == ty

@pytest.mark.parametrize(
    ("operator", "name", "ty"),
    [
        (operator.add, "Addition", {"Secret": {"Rational": {"digits": 3}}}),
        (operator.sub, "Subtraction", {"Secret": {"Rational": {"digits": 3}}}),
        (operator.mul, "Multiplication", {"Secret": {"Rational": {"digits": 6}}}),
        (operator.lt, "LessThan", {"Secret": {"Boolean": None}}),
        (operator.gt, "GreaterThan", {"Secret": {"Boolean": None}}),
        (operator.le, "LessOrEqualThan", {"Secret": {"Boolean": None}}),
        (operator.ge, "GreaterOrEqualThan", {"Secret": {"Boolean": None}}),
        (operator.eq, "Equals", {"Secret": {"Boolean": None}})
    ],
)
def test_binary_operator_rational_secretrational(operator, name, ty):
    left = create_literal(Rational, 4.2, digits=3)
    right = create_input(SecretRational, "right", "party", digits=3)
    program_operation = operator(left, right)
    op = process_operation(program_operation)
    assert list(op.keys()) == [name]

    inner = op[name]

    assert len(literal_reference(inner["left"])) == 32
    assert input_reference(inner["right"]) == "right"
    assert inner["type"] == ty

@pytest.mark.parametrize(
    ("operator", "name", "ty"),
    [
        (operator.add, "Addition", {"Public": {"Rational": {"digits": 3}}}),
        (operator.sub, "Subtraction", {"Public": {"Rational": {"digits": 3}}}),
        (operator.mul, "Multiplication", {"Public": {"Rational": {"digits": 6}}}),
        (operator.truediv, "Division", {"Public": {"Rational": {"digits": 3}}}),
        (operator.lt, "LessThan", {"Public": {"Boolean": None}}),
        (operator.gt, "GreaterThan", {"Public": {"Boolean": None}}),
        (operator.le, "LessOrEqualThan", {"Public": {"Boolean": None}}),
        (operator.ge, "GreaterOrEqualThan", {"Public": {"Boolean": None}}),
        (operator.eq, "Equals", {"Public": {"Boolean": None}})
    ],
)
def test_binary_operator_publicrational_rational(operator, name, ty):
    left = create_input(PublicRational, "left", "party", digits=3)
    right = create_literal(Rational, 4.2, digits=3)
    program_operation = operator(left, right)
    op = process_operation(program_operation)
    assert list(op.keys()) == [name]

    inner = op[name]

    assert input_reference(inner["left"]) == "left"
    assert len(literal_reference(inner["right"])) == 32
    assert inner["type"] == ty

@pytest.mark.parametrize(
    ("operator", "name", "ty"),
    [
        (operator.add, "Addition", {"Public": {"Rational": {"digits": 3}}}),
        (operator.sub, "Subtraction", {"Public": {"Rational": {"digits": 3}}}),
        (operator.mul, "Multiplication", {"Public": {"Rational": {"digits": 6}}}),
        (operator.truediv, "Division", {"Public": {"Rational": {"digits": 3}}}),
        (operator.lt, "LessThan", {"Public": {"Boolean": None}}),
        (operator.gt, "GreaterThan", {"Public": {"Boolean": None}}),
        (operator.le, "LessOrEqualThan", {"Public": {"Boolean": None}}),
        (operator.ge, "GreaterOrEqualThan", {"Public": {"Boolean": None}}),
        (operator.eq, "Equals", {"Public": {"Boolean": None}}),
        (PublicRational.public_equals, "PublicEquals", {"Public": {"Boolean": None}})
    ],
)
def test_binary_operator_publicrational_publicrational(operator, name, ty):
    left = create_input(PublicRational, "left", "party", digits=3)
    right = create_input(PublicRational, "right", "party", digits=3)
    program_operation = operator(left, right)
    op = process_operation(program_operation)
    assert list(op.keys()) == [name]

    inner = op[name]

    assert input_reference(inner["left"]) == "left"
    assert input_reference(inner["right"]) == "right"
    assert inner["type"] == ty

@pytest.mark.parametrize(
    ("operator", "name", "ty"),
    [
        (operator.add, "Addition", {"Secret": {"Rational": {"digits": 3}}}),
        (operator.sub, "Subtraction", {"Secret": {"Rational": {"digits": 3}}}),
        (operator.mul, "Multiplication", {"Secret": {"Rational": {"digits": 6}}}),
        (operator.lt, "LessThan", {"Secret": {"Boolean": None}}),
        (operator.gt, "GreaterThan", {"Secret": {"Boolean": None}}),
        (operator.le, "LessOrEqualThan", {"Secret": {"Boolean": None}}),
        (operator.ge, "GreaterOrEqualThan", {"Secret": {"Boolean": None}}),
        (operator.eq, "Equals", {"Secret": {"Boolean": None}}),
        (PublicRational.public_equals, "PublicEquals", {"Secret": {"Boolean": None}})
    ],
)
def test_binary_operator_publicrational_secretrational(operator, name, ty):
    left = create_input(PublicRational, "left", "party", digits=3)
    right = create_input(SecretRational, "right", "party", digits=3)
    program_operation = operator(left, right)
    op = process_operation(program_operation)
    assert list(op.keys()) == [name]

    inner = op[name]

    assert input_reference(inner["left"]) == "left"
    assert input_reference(inner["right"]) == "right"
    assert inner["type"] == ty

@pytest.mark.parametrize(
    ("operator", "name", "ty"),
    [
        (operator.add, "Addition", {"Secret": {"Rational": {"digits": 3}}}),
        (operator.sub, "Subtraction", {"Secret": {"Rational": {"digits": 3}}}),
        (operator.mul, "Multiplication", {"Secret": {"Rational": {"digits": 6}}}),
        (operator.truediv, "Division", {"Secret": {"Rational": {"digits": 3}}}),
        (operator.lt, "LessThan", {"Secret": {"Boolean": None}}),
        (operator.gt, "GreaterThan", {"Secret": {"Boolean": None}}),
        (operator.le, "LessOrEqualThan", {"Secret": {"Boolean": None}}),
        (operator.ge, "GreaterOrEqualThan", {"Secret": {"Boolean": None}}),
        (operator.eq, "Equals", {"Secret": {"Boolean": None}})
    ],
)
def test_binary_operator_secretrational_rational(operator, name, ty):
    left = create_input(SecretRational, "left", "party", digits=3)
    right = create_literal(Rational, 4.2, digits=3)
    program_operation = operator(left, right)
    op = process_operation(program_operation)
    assert list(op.keys()) == [name]

    inner = op[name]

    assert input_reference(inner["left"]) == "left"
    assert len(literal_reference(inner["right"])) == 32
    assert inner["type"] == ty

@pytest.mark.parametrize(
    ("operator", "name", "ty"),
    [
        (operator.add, "Addition", {"Secret": {"Rational": {"digits": 3}}}),
        (operator.sub, "Subtraction", {"Secret": {"Rational": {"digits": 3}}}),
        (operator.mul, "Multiplication", {"Secret": {"Rational": {"digits": 6}}}),
        (operator.truediv, "Division", {"Secret": {"Rational": {"digits": 3}}}),
        (operator.lt, "LessThan", {"Secret": {"Boolean": None}}),
        (operator.gt, "GreaterThan", {"Secret": {"Boolean": None}}),
        (operator.le, "LessOrEqualThan", {"Secret": {"Boolean": None}}),
        (operator.ge, "GreaterOrEqualThan", {"Secret": {"Boolean": None}}),
        (operator.eq, "Equals", {"Secret": {"Boolean": None}}),
        (SecretRational.public_equals, "PublicEquals", {"Secret": {"Boolean": None}})
    ],
)
def test_binary_operator_secretrational_publicrational(operator, name, ty):
    left = create_input(SecretRational, "left", "party", digits=3)
    right = create_input(PublicRational, "right", "party", digits=3)
    program_operation = operator(left, right)
    op = process_operation(program_operation)
    assert list(op.keys()) == [name]

    inner = op[name]

    assert input_reference(inner["left"]) == "left"
    assert input_reference(inner["right"]) == "right"
    assert inner["type"] == ty

@pytest.mark.parametrize(
    ("operator", "name", "ty"),
    [
        (operator.add, "Addition", {"Secret": {"Rational": {"digits": 3}}}),
        (operator.sub, "Subtraction", {"Secret": {"Rational": {"digits": 3}}}),
        (operator.mul, "Multiplication", {"Secret": {"Rational": {"digits": 6}}}),
        (operator.lt, "LessThan", {"Secret": {"Boolean": None}}),
        (operator.gt, "GreaterThan", {"Secret": {"Boolean": None}}),
        (operator.le, "LessOrEqualThan", {"Secret": {"Boolean": None}}),
        (operator.ge, "GreaterOrEqualThan", {"Secret": {"Boolean": None}}),
        (operator.eq, "Equals", {"Secret": {"Boolean": None}}),
        (SecretRational.public_equals, "PublicEquals", {"Secret": {"Boolean": None}})
    ],
)
def test_binary_operator_secretrational_secretrational(operator, name, ty):
    left = create_input(SecretRational, "left", "party", digits=3)
    right = create_input(SecretRational, "right", "party", digits=3)
    program_operation = operator(left, right)
    op = process_operation(program_operation)
    assert list(op.keys()) == [name]

    inner = op[name]

    assert input_reference(inner["left"]) == "left"
    assert input_reference(inner["right"]) == "right"
    assert inner["type"] == ty

