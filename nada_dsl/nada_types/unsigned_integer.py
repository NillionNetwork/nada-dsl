from . import NadaType
from dataclasses import dataclass
from nada_dsl.circuit_io import Literal
from nada_dsl.nada_types.boolean import Boolean, PublicBoolean, SecretBoolean
from nada_dsl.operations import Addition, Division, Equals, GreaterOrEqualThan, GreaterThan, LeftShift, LessOrEqualThan, LessThan, Modulo, Multiplication, Power, RightShift, Subtraction
from nada_dsl.source_ref import SourceRef
from typing import Union

# This file is automatically generated. Do not edit!

@dataclass
class UnsignedInteger(NadaType):
    value: int

    def __init__(self, value: int):
        super().__init__(inner=Literal(value=value, source_ref=SourceRef.back_frame()))
        if isinstance(value, int):
            self.value = value
        else:
            raise ValueError("Expected {}, got {}".format("int", type(value).__name__))
    def __add__(
        self, other: Union["UnsignedInteger","PublicUnsignedInteger","SecretUnsignedInteger"]
    ) -> Union["UnsignedInteger","PublicUnsignedInteger","SecretUnsignedInteger"]:
        if isinstance(other, UnsignedInteger):
            return UnsignedInteger(value=self.value + other.value)
        elif isinstance(other, PublicUnsignedInteger):
            operation = Addition(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicUnsignedInteger(inner=operation)
        elif isinstance(other, SecretUnsignedInteger):
            operation = Addition(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretUnsignedInteger(inner=operation)
        else:
            raise TypeError("Invalid operation: {} {} {}".format(self, "+", other))
    def __sub__(
        self, other: Union["UnsignedInteger","PublicUnsignedInteger","SecretUnsignedInteger"]
    ) -> Union["UnsignedInteger","PublicUnsignedInteger","SecretUnsignedInteger"]:
        if isinstance(other, UnsignedInteger):
            return UnsignedInteger(value=self.value - other.value)
        elif isinstance(other, PublicUnsignedInteger):
            operation = Subtraction(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicUnsignedInteger(inner=operation)
        elif isinstance(other, SecretUnsignedInteger):
            operation = Subtraction(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretUnsignedInteger(inner=operation)
        else:
            raise TypeError("Invalid operation: {} {} {}".format(self, "-", other))
    def __mul__(
        self, other: Union["UnsignedInteger","PublicUnsignedInteger","SecretUnsignedInteger"]
    ) -> Union["UnsignedInteger","PublicUnsignedInteger","SecretUnsignedInteger"]:
        if isinstance(other, UnsignedInteger):
            return UnsignedInteger(value=self.value * other.value)
        elif isinstance(other, PublicUnsignedInteger):
            operation = Multiplication(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicUnsignedInteger(inner=operation)
        elif isinstance(other, SecretUnsignedInteger):
            operation = Multiplication(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretUnsignedInteger(inner=operation)
        else:
            raise TypeError("Invalid operation: {} {} {}".format(self, "*", other))
    def __truediv__(
        self, other: Union["UnsignedInteger","PublicUnsignedInteger"]
    ) -> Union["UnsignedInteger","PublicUnsignedInteger"]:
        if isinstance(other, UnsignedInteger):
            return UnsignedInteger(value=self.value / other.value)
        elif isinstance(other, PublicUnsignedInteger):
            operation = Division(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicUnsignedInteger(inner=operation)
        else:
            raise TypeError("Invalid operation: {} {} {}".format(self, "/", other))
    def __mod__(
        self, other: Union["UnsignedInteger","PublicUnsignedInteger"]
    ) -> Union["UnsignedInteger","PublicUnsignedInteger"]:
        if isinstance(other, UnsignedInteger):
            return UnsignedInteger(value=self.value % other.value)
        elif isinstance(other, PublicUnsignedInteger):
            operation = Modulo(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicUnsignedInteger(inner=operation)
        else:
            raise TypeError("Invalid operation: {} {} {}".format(self, "%", other))
    def __pow__(
        self, other: Union["UnsignedInteger","PublicUnsignedInteger"]
    ) -> Union["UnsignedInteger","PublicUnsignedInteger"]:
        if isinstance(other, UnsignedInteger):
            return UnsignedInteger(value=self.value ** other.value)
        elif isinstance(other, PublicUnsignedInteger):
            operation = Power(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicUnsignedInteger(inner=operation)
        else:
            raise TypeError("Invalid operation: {} {} {}".format(self, "**", other))
    def __lshift__(
        self, other: Union["UnsignedInteger","PublicUnsignedInteger"]
    ) -> Union["UnsignedInteger","PublicUnsignedInteger"]:
        if isinstance(other, UnsignedInteger):
            return UnsignedInteger(value=self.value << other.value)
        elif isinstance(other, PublicUnsignedInteger):
            operation = LeftShift(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicUnsignedInteger(inner=operation)
        else:
            raise TypeError("Invalid operation: {} {} {}".format(self, "<<", other))
    def __rshift__(
        self, other: Union["UnsignedInteger","PublicUnsignedInteger"]
    ) -> Union["UnsignedInteger","PublicUnsignedInteger"]:
        if isinstance(other, UnsignedInteger):
            return UnsignedInteger(value=self.value >> other.value)
        elif isinstance(other, PublicUnsignedInteger):
            operation = RightShift(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicUnsignedInteger(inner=operation)
        else:
            raise TypeError("Invalid operation: {} {} {}".format(self, ">>", other))
    def __lt_(
        self, other: Union["UnsignedInteger","PublicUnsignedInteger"]
    ) -> Union["Boolean","PublicBoolean"]:
        if isinstance(other, UnsignedInteger):
            return Boolean(value=self.value < other.value)
        elif isinstance(other, PublicUnsignedInteger):
            operation = LessThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicBoolean(inner=operation)
        else:
            raise TypeError("Invalid operation: {} {} {}".format(self, "<", other))
    def __gt__(
        self, other: Union["UnsignedInteger","PublicUnsignedInteger"]
    ) -> Union["Boolean","PublicBoolean"]:
        if isinstance(other, UnsignedInteger):
            return Boolean(value=self.value > other.value)
        elif isinstance(other, PublicUnsignedInteger):
            operation = GreaterThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicBoolean(inner=operation)
        else:
            raise TypeError("Invalid operation: {} {} {}".format(self, ">", other))
    def __le__(
        self, other: Union["UnsignedInteger","PublicUnsignedInteger"]
    ) -> Union["Boolean","PublicBoolean"]:
        if isinstance(other, UnsignedInteger):
            return Boolean(value=self.value <= other.value)
        elif isinstance(other, PublicUnsignedInteger):
            operation = LessOrEqualThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicBoolean(inner=operation)
        else:
            raise TypeError("Invalid operation: {} {} {}".format(self, "<=", other))
    def __ge__(
        self, other: Union["UnsignedInteger","PublicUnsignedInteger"]
    ) -> Union["Boolean","PublicBoolean"]:
        if isinstance(other, UnsignedInteger):
            return Boolean(value=self.value >= other.value)
        elif isinstance(other, PublicUnsignedInteger):
            operation = GreaterOrEqualThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicBoolean(inner=operation)
        else:
            raise TypeError("Invalid operation: {} {} {}".format(self, ">=", other))
    def __eq__(
        self, other: Union["UnsignedInteger","PublicUnsignedInteger"]
    ) -> Union["Boolean","PublicBoolean"]:
        if isinstance(other, UnsignedInteger):
            return Boolean(value=self.value == other.value)
        elif isinstance(other, PublicUnsignedInteger):
            operation = Equals(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicBoolean(inner=operation)
        else:
            raise TypeError("Invalid operation: {} {} {}".format(self, "==", other))
@dataclass
class PublicUnsignedInteger(NadaType):
    def __add__(
        self, other: Union["UnsignedInteger","PublicUnsignedInteger","SecretUnsignedInteger"]
    ) -> Union["PublicUnsignedInteger","PublicUnsignedInteger","SecretUnsignedInteger"]:
        if isinstance(other, UnsignedInteger):
            operation = Addition(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicUnsignedInteger(inner=operation)
        elif isinstance(other, PublicUnsignedInteger):
            operation = Addition(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicUnsignedInteger(inner=operation)
        elif isinstance(other, SecretUnsignedInteger):
            operation = Addition(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretUnsignedInteger(inner=operation)
        else:
            raise TypeError("Invalid operation: {} {} {}".format(self, "+", other))
    def __sub__(
        self, other: Union["UnsignedInteger","PublicUnsignedInteger","SecretUnsignedInteger"]
    ) -> Union["PublicUnsignedInteger","PublicUnsignedInteger","SecretUnsignedInteger"]:
        if isinstance(other, UnsignedInteger):
            operation = Subtraction(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicUnsignedInteger(inner=operation)
        elif isinstance(other, PublicUnsignedInteger):
            operation = Subtraction(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicUnsignedInteger(inner=operation)
        elif isinstance(other, SecretUnsignedInteger):
            operation = Subtraction(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretUnsignedInteger(inner=operation)
        else:
            raise TypeError("Invalid operation: {} {} {}".format(self, "-", other))
    def __mul__(
        self, other: Union["UnsignedInteger","PublicUnsignedInteger","SecretUnsignedInteger"]
    ) -> Union["PublicUnsignedInteger","PublicUnsignedInteger","SecretUnsignedInteger"]:
        if isinstance(other, UnsignedInteger):
            operation = Multiplication(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicUnsignedInteger(inner=operation)
        elif isinstance(other, PublicUnsignedInteger):
            operation = Multiplication(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicUnsignedInteger(inner=operation)
        elif isinstance(other, SecretUnsignedInteger):
            operation = Multiplication(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretUnsignedInteger(inner=operation)
        else:
            raise TypeError("Invalid operation: {} {} {}".format(self, "*", other))
    def __truediv__(
        self, other: Union["UnsignedInteger","PublicUnsignedInteger"]
    ) -> Union["PublicUnsignedInteger","PublicUnsignedInteger"]:
        if isinstance(other, UnsignedInteger):
            operation = Division(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicUnsignedInteger(inner=operation)
        elif isinstance(other, PublicUnsignedInteger):
            operation = Division(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicUnsignedInteger(inner=operation)
        else:
            raise TypeError("Invalid operation: {} {} {}".format(self, "/", other))
    def __mod__(
        self, other: Union["UnsignedInteger","PublicUnsignedInteger"]
    ) -> Union["PublicUnsignedInteger","PublicUnsignedInteger"]:
        if isinstance(other, UnsignedInteger):
            operation = Modulo(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicUnsignedInteger(inner=operation)
        elif isinstance(other, PublicUnsignedInteger):
            operation = Modulo(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicUnsignedInteger(inner=operation)
        else:
            raise TypeError("Invalid operation: {} {} {}".format(self, "%", other))
    def __pow__(
        self, other: Union["UnsignedInteger","PublicUnsignedInteger"]
    ) -> Union["PublicUnsignedInteger","PublicUnsignedInteger"]:
        if isinstance(other, UnsignedInteger):
            operation = Power(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicUnsignedInteger(inner=operation)
        elif isinstance(other, PublicUnsignedInteger):
            operation = Power(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicUnsignedInteger(inner=operation)
        else:
            raise TypeError("Invalid operation: {} {} {}".format(self, "**", other))
    def __lshift__(
        self, other: Union["UnsignedInteger","PublicUnsignedInteger"]
    ) -> Union["PublicUnsignedInteger","PublicUnsignedInteger"]:
        if isinstance(other, UnsignedInteger):
            operation = LeftShift(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicUnsignedInteger(inner=operation)
        elif isinstance(other, PublicUnsignedInteger):
            operation = LeftShift(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicUnsignedInteger(inner=operation)
        else:
            raise TypeError("Invalid operation: {} {} {}".format(self, "<<", other))
    def __rshift__(
        self, other: Union["UnsignedInteger","PublicUnsignedInteger"]
    ) -> Union["PublicUnsignedInteger","PublicUnsignedInteger"]:
        if isinstance(other, UnsignedInteger):
            operation = RightShift(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicUnsignedInteger(inner=operation)
        elif isinstance(other, PublicUnsignedInteger):
            operation = RightShift(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicUnsignedInteger(inner=operation)
        else:
            raise TypeError("Invalid operation: {} {} {}".format(self, ">>", other))
    def __lt_(
        self, other: Union["UnsignedInteger","PublicUnsignedInteger"]
    ) -> Union["PublicBoolean","PublicBoolean"]:
        if isinstance(other, UnsignedInteger):
            operation = LessThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicBoolean(inner=operation)
        elif isinstance(other, PublicUnsignedInteger):
            operation = LessThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicBoolean(inner=operation)
        else:
            raise TypeError("Invalid operation: {} {} {}".format(self, "<", other))
    def __gt__(
        self, other: Union["UnsignedInteger","PublicUnsignedInteger"]
    ) -> Union["PublicBoolean","PublicBoolean"]:
        if isinstance(other, UnsignedInteger):
            operation = GreaterThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicBoolean(inner=operation)
        elif isinstance(other, PublicUnsignedInteger):
            operation = GreaterThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicBoolean(inner=operation)
        else:
            raise TypeError("Invalid operation: {} {} {}".format(self, ">", other))
    def __le__(
        self, other: Union["UnsignedInteger","PublicUnsignedInteger"]
    ) -> Union["PublicBoolean","PublicBoolean"]:
        if isinstance(other, UnsignedInteger):
            operation = LessOrEqualThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicBoolean(inner=operation)
        elif isinstance(other, PublicUnsignedInteger):
            operation = LessOrEqualThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicBoolean(inner=operation)
        else:
            raise TypeError("Invalid operation: {} {} {}".format(self, "<=", other))
    def __ge__(
        self, other: Union["UnsignedInteger","PublicUnsignedInteger"]
    ) -> Union["PublicBoolean","PublicBoolean"]:
        if isinstance(other, UnsignedInteger):
            operation = GreaterOrEqualThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicBoolean(inner=operation)
        elif isinstance(other, PublicUnsignedInteger):
            operation = GreaterOrEqualThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicBoolean(inner=operation)
        else:
            raise TypeError("Invalid operation: {} {} {}".format(self, ">=", other))
    def __eq__(
        self, other: Union["UnsignedInteger","PublicUnsignedInteger"]
    ) -> Union["PublicBoolean","PublicBoolean"]:
        if isinstance(other, UnsignedInteger):
            operation = Equals(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicBoolean(inner=operation)
        elif isinstance(other, PublicUnsignedInteger):
            operation = Equals(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicBoolean(inner=operation)
        else:
            raise TypeError("Invalid operation: {} {} {}".format(self, "==", other))
@dataclass
class SecretUnsignedInteger(NadaType):
    def __add__(
        self, other: Union["UnsignedInteger","PublicUnsignedInteger","SecretUnsignedInteger"]
    ) -> Union["SecretUnsignedInteger","SecretUnsignedInteger","SecretUnsignedInteger"]:
        if isinstance(other, UnsignedInteger):
            operation = Addition(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretUnsignedInteger(inner=operation)
        elif isinstance(other, PublicUnsignedInteger):
            operation = Addition(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretUnsignedInteger(inner=operation)
        elif isinstance(other, SecretUnsignedInteger):
            operation = Addition(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretUnsignedInteger(inner=operation)
        else:
            raise TypeError("Invalid operation: {} {} {}".format(self, "+", other))
    def __sub__(
        self, other: Union["UnsignedInteger","PublicUnsignedInteger","SecretUnsignedInteger"]
    ) -> Union["SecretUnsignedInteger","SecretUnsignedInteger","SecretUnsignedInteger"]:
        if isinstance(other, UnsignedInteger):
            operation = Subtraction(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretUnsignedInteger(inner=operation)
        elif isinstance(other, PublicUnsignedInteger):
            operation = Subtraction(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretUnsignedInteger(inner=operation)
        elif isinstance(other, SecretUnsignedInteger):
            operation = Subtraction(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretUnsignedInteger(inner=operation)
        else:
            raise TypeError("Invalid operation: {} {} {}".format(self, "-", other))
    def __mul__(
        self, other: Union["UnsignedInteger","PublicUnsignedInteger","SecretUnsignedInteger"]
    ) -> Union["SecretUnsignedInteger","SecretUnsignedInteger","SecretUnsignedInteger"]:
        if isinstance(other, UnsignedInteger):
            operation = Multiplication(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretUnsignedInteger(inner=operation)
        elif isinstance(other, PublicUnsignedInteger):
            operation = Multiplication(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretUnsignedInteger(inner=operation)
        elif isinstance(other, SecretUnsignedInteger):
            operation = Multiplication(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretUnsignedInteger(inner=operation)
        else:
            raise TypeError("Invalid operation: {} {} {}".format(self, "*", other))
    def __truediv__(
        self, other: Union["UnsignedInteger","PublicUnsignedInteger"]
    ) -> Union["SecretUnsignedInteger","SecretUnsignedInteger"]:
        if isinstance(other, UnsignedInteger):
            operation = Division(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretUnsignedInteger(inner=operation)
        elif isinstance(other, PublicUnsignedInteger):
            operation = Division(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretUnsignedInteger(inner=operation)
        else:
            raise TypeError("Invalid operation: {} {} {}".format(self, "/", other))
    def __mod__(
        self, other: Union["UnsignedInteger","PublicUnsignedInteger"]
    ) -> Union["SecretUnsignedInteger","SecretUnsignedInteger"]:
        if isinstance(other, UnsignedInteger):
            operation = Modulo(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretUnsignedInteger(inner=operation)
        elif isinstance(other, PublicUnsignedInteger):
            operation = Modulo(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretUnsignedInteger(inner=operation)
        else:
            raise TypeError("Invalid operation: {} {} {}".format(self, "%", other))
    def __pow__(
        self, other: Union["UnsignedInteger","PublicUnsignedInteger"]
    ) -> Union["SecretUnsignedInteger","SecretUnsignedInteger"]:
        if isinstance(other, UnsignedInteger):
            operation = Power(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretUnsignedInteger(inner=operation)
        elif isinstance(other, PublicUnsignedInteger):
            operation = Power(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretUnsignedInteger(inner=operation)
        else:
            raise TypeError("Invalid operation: {} {} {}".format(self, "**", other))
    def __lshift__(
        self, other: Union["UnsignedInteger","PublicUnsignedInteger"]
    ) -> Union["SecretUnsignedInteger","SecretUnsignedInteger"]:
        if isinstance(other, UnsignedInteger):
            operation = LeftShift(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretUnsignedInteger(inner=operation)
        elif isinstance(other, PublicUnsignedInteger):
            operation = LeftShift(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretUnsignedInteger(inner=operation)
        else:
            raise TypeError("Invalid operation: {} {} {}".format(self, "<<", other))
    def __rshift__(
        self, other: Union["UnsignedInteger","PublicUnsignedInteger"]
    ) -> Union["SecretUnsignedInteger","SecretUnsignedInteger"]:
        if isinstance(other, UnsignedInteger):
            operation = RightShift(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretUnsignedInteger(inner=operation)
        elif isinstance(other, PublicUnsignedInteger):
            operation = RightShift(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretUnsignedInteger(inner=operation)
        else:
            raise TypeError("Invalid operation: {} {} {}".format(self, ">>", other))
    def __lt_(
        self, other: Union["UnsignedInteger","PublicUnsignedInteger"]
    ) -> Union["SecretBoolean","SecretBoolean"]:
        if isinstance(other, UnsignedInteger):
            operation = LessThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretBoolean(inner=operation)
        elif isinstance(other, PublicUnsignedInteger):
            operation = LessThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretBoolean(inner=operation)
        else:
            raise TypeError("Invalid operation: {} {} {}".format(self, "<", other))
    def __gt__(
        self, other: Union["UnsignedInteger","PublicUnsignedInteger"]
    ) -> Union["SecretBoolean","SecretBoolean"]:
        if isinstance(other, UnsignedInteger):
            operation = GreaterThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretBoolean(inner=operation)
        elif isinstance(other, PublicUnsignedInteger):
            operation = GreaterThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretBoolean(inner=operation)
        else:
            raise TypeError("Invalid operation: {} {} {}".format(self, ">", other))
    def __le__(
        self, other: Union["UnsignedInteger","PublicUnsignedInteger"]
    ) -> Union["SecretBoolean","SecretBoolean"]:
        if isinstance(other, UnsignedInteger):
            operation = LessOrEqualThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretBoolean(inner=operation)
        elif isinstance(other, PublicUnsignedInteger):
            operation = LessOrEqualThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretBoolean(inner=operation)
        else:
            raise TypeError("Invalid operation: {} {} {}".format(self, "<=", other))
    def __ge__(
        self, other: Union["UnsignedInteger","PublicUnsignedInteger"]
    ) -> Union["SecretBoolean","SecretBoolean"]:
        if isinstance(other, UnsignedInteger):
            operation = GreaterOrEqualThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretBoolean(inner=operation)
        elif isinstance(other, PublicUnsignedInteger):
            operation = GreaterOrEqualThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretBoolean(inner=operation)
        else:
            raise TypeError("Invalid operation: {} {} {}".format(self, ">=", other))
