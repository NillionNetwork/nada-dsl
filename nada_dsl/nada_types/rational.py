# This file is automatically generated. Do not edit!

from . import NadaType
from dataclasses import dataclass
from nada_dsl.circuit_io import Literal
from nada_dsl.nada_types.boolean import Boolean, PublicBoolean, SecretBoolean
from nada_dsl.operations import Addition, Division, GreaterOrEqualThan, GreaterThan, LessOrEqualThan, LessThan, Multiplication, Subtraction
from nada_dsl.source_ref import SourceRef
from typing import Union

@dataclass
class Rational(NadaType):
    digits: int
    value: float

    def __init__(self, value: float):
        super().__init__(inner=Literal(value=value, source_ref=SourceRef.back_frame()))
        if isinstance(value, float):
            self.value = value
        else:
            raise ValueError(f"Expected float, got {type(value).__name__}")

    def __add__(
        self, other: Union["PublicRational", "Rational", "SecretRational"]
    ) -> Union["PublicRational", "Rational", "SecretRational"]:
        if isinstance(other, Rational) and other.digits == self.digits:
            return Rational(value=self.value + other.value)
        elif isinstance(other, PublicRational) and other.digits == self.digits:
            operation = Addition(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicRational(inner=operation, digits=self.digits)
        elif isinstance(other, SecretRational) and other.digits == self.digits:
            operation = Addition(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretRational(inner=operation, digits=self.digits)
        else:
            raise TypeError(f"Invalid operation: {self} + {other}")

    def __sub__(
        self, other: Union["PublicRational", "Rational", "SecretRational"]
    ) -> Union["PublicRational", "Rational", "SecretRational"]:
        if isinstance(other, Rational) and other.digits == self.digits:
            return Rational(value=self.value - other.value)
        elif isinstance(other, PublicRational) and other.digits == self.digits:
            operation = Subtraction(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicRational(inner=operation, digits=self.digits)
        elif isinstance(other, SecretRational) and other.digits == self.digits:
            operation = Subtraction(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretRational(inner=operation, digits=self.digits)
        else:
            raise TypeError(f"Invalid operation: {self} - {other}")

    def __mul__(
        self, other: Union["PublicRational", "Rational", "SecretRational"]
    ) -> Union["PublicRational", "Rational", "SecretRational"]:
        if isinstance(other, Rational):
            digits = self.digits + other.digits
            return Rational(value=self.value, digits=digits * other.value)
        elif isinstance(other, PublicRational):
            digits = self.digits + other.digits
            operation = Multiplication(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicRational(inner=operation, digits=digits)
        elif isinstance(other, SecretRational):
            digits = self.digits + other.digits
            operation = Multiplication(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretRational(inner=operation, digits=digits)
        else:
            raise TypeError(f"Invalid operation: {self} * {other}")

    def __truediv__(
        self, other: Union["PublicRational", "Rational"]
    ) -> Union["PublicRational", "Rational"]:
        if isinstance(other, Rational) and other.digits == self.digits:
            return Rational(value=self.value / other.value)
        elif isinstance(other, PublicRational) and other.digits == self.digits:
            operation = Division(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicRational(inner=operation, digits=self.digits)
        else:
            raise TypeError(f"Invalid operation: {self} / {other}")

    def __lt__(
        self, other: Union["PublicRational", "Rational", "SecretRational"]
    ) -> Union["Boolean", "PublicBoolean", "SecretBoolean"]:
        if isinstance(other, Rational) and other.digits == self.digits:
            return Boolean(value=self.value < other.value)
        elif isinstance(other, PublicRational) and other.digits == self.digits:
            operation = LessThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicBoolean(inner=operation)
        elif isinstance(other, SecretRational) and other.digits == self.digits:
            operation = LessThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretBoolean(inner=operation)
        else:
            raise TypeError(f"Invalid operation: {self} < {other}")

    def __gt__(
        self, other: Union["PublicRational", "Rational", "SecretRational"]
    ) -> Union["Boolean", "PublicBoolean", "SecretBoolean"]:
        if isinstance(other, Rational) and other.digits == self.digits:
            return Boolean(value=self.value > other.value)
        elif isinstance(other, PublicRational) and other.digits == self.digits:
            operation = GreaterThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicBoolean(inner=operation)
        elif isinstance(other, SecretRational) and other.digits == self.digits:
            operation = GreaterThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretBoolean(inner=operation)
        else:
            raise TypeError(f"Invalid operation: {self} > {other}")

    def __le__(
        self, other: Union["PublicRational", "Rational", "SecretRational"]
    ) -> Union["Boolean", "PublicBoolean", "SecretBoolean"]:
        if isinstance(other, Rational) and other.digits == self.digits:
            return Boolean(value=self.value <= other.value)
        elif isinstance(other, PublicRational) and other.digits == self.digits:
            operation = LessOrEqualThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicBoolean(inner=operation)
        elif isinstance(other, SecretRational) and other.digits == self.digits:
            operation = LessOrEqualThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretBoolean(inner=operation)
        else:
            raise TypeError(f"Invalid operation: {self} <= {other}")

    def __ge__(
        self, other: Union["PublicRational", "Rational", "SecretRational"]
    ) -> Union["Boolean", "PublicBoolean", "SecretBoolean"]:
        if isinstance(other, Rational) and other.digits == self.digits:
            return Boolean(value=self.value >= other.value)
        elif isinstance(other, PublicRational) and other.digits == self.digits:
            operation = GreaterOrEqualThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicBoolean(inner=operation)
        elif isinstance(other, SecretRational) and other.digits == self.digits:
            operation = GreaterOrEqualThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretBoolean(inner=operation)
        else:
            raise TypeError(f"Invalid operation: {self} >= {other}")

@dataclass
class PublicRational(NadaType):
    digits: int
    def __add__(
        self, other: Union["PublicRational", "Rational", "SecretRational"]
    ) -> Union["PublicRational", "SecretRational"]:
        if isinstance(other, Rational) and other.digits == self.digits:
            operation = Addition(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicRational(inner=operation, digits=self.digits)
        elif isinstance(other, PublicRational) and other.digits == self.digits:
            operation = Addition(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicRational(inner=operation, digits=self.digits)
        elif isinstance(other, SecretRational) and other.digits == self.digits:
            operation = Addition(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretRational(inner=operation, digits=self.digits)
        else:
            raise TypeError(f"Invalid operation: {self} + {other}")

    def __sub__(
        self, other: Union["PublicRational", "Rational", "SecretRational"]
    ) -> Union["PublicRational", "SecretRational"]:
        if isinstance(other, Rational) and other.digits == self.digits:
            operation = Subtraction(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicRational(inner=operation, digits=self.digits)
        elif isinstance(other, PublicRational) and other.digits == self.digits:
            operation = Subtraction(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicRational(inner=operation, digits=self.digits)
        elif isinstance(other, SecretRational) and other.digits == self.digits:
            operation = Subtraction(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretRational(inner=operation, digits=self.digits)
        else:
            raise TypeError(f"Invalid operation: {self} - {other}")

    def __mul__(
        self, other: Union["PublicRational", "Rational", "SecretRational"]
    ) -> Union["PublicRational", "SecretRational"]:
        if isinstance(other, Rational):
            digits = self.digits + other.digits
            operation = Multiplication(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicRational(inner=operation, digits=digits)
        elif isinstance(other, PublicRational):
            digits = self.digits + other.digits
            operation = Multiplication(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicRational(inner=operation, digits=digits)
        elif isinstance(other, SecretRational):
            digits = self.digits + other.digits
            operation = Multiplication(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretRational(inner=operation, digits=digits)
        else:
            raise TypeError(f"Invalid operation: {self} * {other}")

    def __truediv__(
        self, other: Union["PublicRational", "Rational"]
    ) -> "PublicRational":
        if isinstance(other, Rational) and other.digits == self.digits:
            operation = Division(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicRational(inner=operation, digits=self.digits)
        elif isinstance(other, PublicRational) and other.digits == self.digits:
            operation = Division(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicRational(inner=operation, digits=self.digits)
        else:
            raise TypeError(f"Invalid operation: {self} / {other}")

    def __lt__(
        self, other: Union["PublicRational", "Rational"]
    ) -> "PublicBoolean":
        if isinstance(other, Rational) and other.digits == self.digits:
            operation = LessThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicBoolean(inner=operation)
        elif isinstance(other, PublicRational) and other.digits == self.digits:
            operation = LessThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicBoolean(inner=operation)
        else:
            raise TypeError(f"Invalid operation: {self} < {other}")

    def __gt__(
        self, other: Union["PublicRational", "Rational"]
    ) -> "PublicBoolean":
        if isinstance(other, Rational) and other.digits == self.digits:
            operation = GreaterThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicBoolean(inner=operation)
        elif isinstance(other, PublicRational) and other.digits == self.digits:
            operation = GreaterThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicBoolean(inner=operation)
        else:
            raise TypeError(f"Invalid operation: {self} > {other}")

    def __le__(
        self, other: Union["PublicRational", "Rational"]
    ) -> "PublicBoolean":
        if isinstance(other, Rational) and other.digits == self.digits:
            operation = LessOrEqualThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicBoolean(inner=operation)
        elif isinstance(other, PublicRational) and other.digits == self.digits:
            operation = LessOrEqualThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicBoolean(inner=operation)
        else:
            raise TypeError(f"Invalid operation: {self} <= {other}")

    def __ge__(
        self, other: Union["PublicRational", "Rational"]
    ) -> "PublicBoolean":
        if isinstance(other, Rational) and other.digits == self.digits:
            operation = GreaterOrEqualThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicBoolean(inner=operation)
        elif isinstance(other, PublicRational) and other.digits == self.digits:
            operation = GreaterOrEqualThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return PublicBoolean(inner=operation)
        else:
            raise TypeError(f"Invalid operation: {self} >= {other}")

@dataclass
class SecretRational(NadaType):
    digits: int
    def __add__(
        self, other: Union["PublicRational", "Rational", "SecretRational"]
    ) -> "SecretRational":
        if isinstance(other, Rational) and other.digits == self.digits:
            operation = Addition(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretRational(inner=operation, digits=self.digits)
        elif isinstance(other, PublicRational) and other.digits == self.digits:
            operation = Addition(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretRational(inner=operation, digits=self.digits)
        elif isinstance(other, SecretRational) and other.digits == self.digits:
            operation = Addition(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretRational(inner=operation, digits=self.digits)
        else:
            raise TypeError(f"Invalid operation: {self} + {other}")

    def __sub__(
        self, other: Union["PublicRational", "Rational", "SecretRational"]
    ) -> "SecretRational":
        if isinstance(other, Rational) and other.digits == self.digits:
            operation = Subtraction(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretRational(inner=operation, digits=self.digits)
        elif isinstance(other, PublicRational) and other.digits == self.digits:
            operation = Subtraction(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretRational(inner=operation, digits=self.digits)
        elif isinstance(other, SecretRational) and other.digits == self.digits:
            operation = Subtraction(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretRational(inner=operation, digits=self.digits)
        else:
            raise TypeError(f"Invalid operation: {self} - {other}")

    def __mul__(
        self, other: Union["PublicRational", "Rational", "SecretRational"]
    ) -> "SecretRational":
        if isinstance(other, Rational):
            digits = self.digits + other.digits
            operation = Multiplication(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretRational(inner=operation, digits=digits)
        elif isinstance(other, PublicRational):
            digits = self.digits + other.digits
            operation = Multiplication(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretRational(inner=operation, digits=digits)
        elif isinstance(other, SecretRational):
            digits = self.digits + other.digits
            operation = Multiplication(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretRational(inner=operation, digits=digits)
        else:
            raise TypeError(f"Invalid operation: {self} * {other}")

    def __truediv__(
        self, other: Union["PublicRational", "Rational"]
    ) -> "SecretRational":
        if isinstance(other, Rational) and other.digits == self.digits:
            operation = Division(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretRational(inner=operation, digits=self.digits)
        elif isinstance(other, PublicRational) and other.digits == self.digits:
            operation = Division(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretRational(inner=operation, digits=self.digits)
        else:
            raise TypeError(f"Invalid operation: {self} / {other}")

    def __lt__(
        self, other: Union["Rational", "SecretRational"]
    ) -> "SecretBoolean":
        if isinstance(other, Rational) and other.digits == self.digits:
            operation = LessThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretBoolean(inner=operation)
        elif isinstance(other, SecretRational) and other.digits == self.digits:
            operation = LessThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretBoolean(inner=operation)
        else:
            raise TypeError(f"Invalid operation: {self} < {other}")

    def __gt__(
        self, other: Union["Rational", "SecretRational"]
    ) -> "SecretBoolean":
        if isinstance(other, Rational) and other.digits == self.digits:
            operation = GreaterThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretBoolean(inner=operation)
        elif isinstance(other, SecretRational) and other.digits == self.digits:
            operation = GreaterThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretBoolean(inner=operation)
        else:
            raise TypeError(f"Invalid operation: {self} > {other}")

    def __le__(
        self, other: Union["Rational", "SecretRational"]
    ) -> "SecretBoolean":
        if isinstance(other, Rational) and other.digits == self.digits:
            operation = LessOrEqualThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretBoolean(inner=operation)
        elif isinstance(other, SecretRational) and other.digits == self.digits:
            operation = LessOrEqualThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretBoolean(inner=operation)
        else:
            raise TypeError(f"Invalid operation: {self} <= {other}")

    def __ge__(
        self, other: Union["Rational", "SecretRational"]
    ) -> "SecretBoolean":
        if isinstance(other, Rational) and other.digits == self.digits:
            operation = GreaterOrEqualThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretBoolean(inner=operation)
        elif isinstance(other, SecretRational) and other.digits == self.digits:
            operation = GreaterOrEqualThan(left=self, right=other, source_ref=SourceRef.back_frame())
            return SecretBoolean(inner=operation)
        else:
            raise TypeError(f"Invalid operation: {self} >= {other}")

